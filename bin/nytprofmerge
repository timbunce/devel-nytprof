#!/usr/bin/perl
##########################################################
# This script is part of the Devel::NYTProf distribution
#
# Copyright, contact and other information can be found
# at the bottom of this file, or by going to:
# http://search.cpan.org/dist/Devel-NYTProf/
#
##########################################################
# $Id$
##########################################################

use warnings;
use strict;

use Devel::NYTProf::Core;
require Devel::NYTProf::FileHandle;
use Devel::NYTProf::ReadStream qw(for_chunks);
use List::Util qw(min);

our $VERSION = '3.02';
    
if ($VERSION != $Devel::NYTProf::Core::VERSION) {
    die "$0 version '$VERSION' doesn't match version '$Devel::NYTProf::Core::VERSION' of $INC{'Devel/NYTProf/Core.pm'}\n";
}

use Getopt::Long;
use Carp;

my $opt_out = 'nytprof-merged.out';

GetOptions(
    'out|o=s'   => \$opt_out,
    'help|h'    => \&usage,
    'verbose|v' => \my $opt_verbose,
) or usage();


print "Writing $opt_out\n" if $opt_verbose;
my $out = Devel::NYTProf::FileHandle::open($opt_out, "wb")
    or die "Error opening $opt_out: $!\n";

my $sub_is_anon_in_eval = qr/__ANON__\[\(eval/;

my $next_fid = 1;
my %fid_to_file;
my %file_to_fid;
my %fids = (0 => 0);
# Similar, but with all evals folded too
my %fids_folded = (0 => 0);

my %eval_to_fid;

my $version;
my %seen_subs;
my %callers;
my %map_range;

my @pending_fids;
my %pending_subs;

sub _time_block_or_line {
    my ($tag, undef, undef, $ticks, $fid, $line, $block_line, $sub_line) = @_;
    my $is_line = $tag eq 'TIME_LINE';

    confess("No mapping for $fid") unless defined $fids{$fid};
    $fid = $fids{$fid};
    # Is this a subroutine (re)defined in an eval?
    my $mapped_fid = $map_range{$fid}[$line];
    $fid = $mapped_fid if defined $mapped_fid;

    $out->write($is_line ? '+' : '*');
    $out->output_int($ticks, $fid, $line);
    if (!$is_line) {
	$out->output_int($block_line);
	$out->output_int($sub_line);
    }
}

# Croak if any of these attributes differ between profiles
my %identical = map {$_, 1}
    qw (PL_perldb clock_id nv_size perl_version
	ticks_per_sec xs_version);

# Effectively, these are global variables. Sorry.
my $input;
my %attributes;
my $deflating;

my %dispatcher =
    (
     VERSION => sub {
	 my (undef, $major, $minor) = @_;
	 my $this_version = "$major $minor";
	 if($version) {
	     die "Incompatible version '$this_version' in $input, expected '$version'"
		 unless $this_version eq $version;
	 } else {
	     $version = $this_version;
	     $out->write("NYTProf $version\n");
	 }
     },
     COMMENT => sub {
	 my (undef, $text) = @_;
	 # This isn't true unless we enable compression ourselves, and if we
	 # do that, the low level code will write out a correct comment
	 # automatically.
	 return if $text =~ /\ACompressed at level \d with zlib [0-9.]+\n\z/;
	 $out->write("#$text")
     },
     ATTRIBUTE => sub {
	 my (undef, $key, $value) = @_;
	 if ($identical{$key}) {
	     if (exists $attributes{$key}) {
		 if ($attributes{$key} ne $value) {
		     die ("In $input, attribute '$key' has value '$value', which differs from the previous value for that key, '$attributes{$key}'\n");
		 }
	     } else {
		 $attributes{$key} = $value;
		 $out->write(":$key=$value\n");
	     }
	 } else {
	     push @{$attributes{$key}}, $value;
	 }
     },

     START_DEFLATE => sub {
	 if (!$deflating && $out->can('start_deflate')) {
	     $out->write('z');
	     $out->start_deflate;
	     ++$deflating;
	 }
     },

     PID_START => sub {
	 my (undef, $pid, $parent, $time) = @_;
	 $out->write('P');
	 $out->output_int($pid, $parent);
	 $out->output_nv($time);
     },
     PID_END => sub {
	 my (undef, $pid, $time) = @_;
	 $out->write('p');
	 $out->output_int($pid);
	 $out->output_nv($time);
     },

     NEW_FID => sub {
	 my (undef, $fid, $eval_fid, $eval_line, $flags, $size, $mtime, $name) = @_;

	 return unless $pending_fids[$fid];
	 my ($new_fid, $new_eval_fid) = @{$pending_fids[$fid]};

	 $out->write('@');
	 $out->output_int($new_fid, $new_eval_fid, $eval_line, $flags, $size, $mtime);
	 $out->output_str($name);
     },
     TIME_BLOCK => \&_time_block_or_line,
     TIME_LINE => \&_time_block_or_line,

     DISCOUNT => sub {
	 $out->write('-');
     },
     SUB_INFO => sub {
	 my (undef, $fid, $first_line, $last_line, $name) = @_;

	 my $output_fid = $pending_subs{"$fid,$first_line,$last_line,$name"};
	 return unless defined $output_fid;

	 $out->write('s');
	 $out->output_int($output_fid);
	 $out->output_str($name);
	 $out->output_int($first_line, $last_line, 0);
     },
     SUB_CALLERS => sub {
	 my (undef, $fid, $line, $count, $incl_time, $excl_time, $ucpu_time, $scpu_time, $reci_time, $rec_depth, $called, $caller) = @_;
	 confess("No mapping for $fid") unless defined $fids{$fid};
	 $fid = $fids{$fid};
	 my $mapped_fid = $map_range{$fid}[$line];
	 $fid = $mapped_fid if defined $mapped_fid;

	 if ($callers{"$fid,$line"}{$called}{$caller}) {
	     my $sum = $callers{"$fid,$line"}{$called}{$caller};
	     $sum->{count} += $count;
	     $sum->{incl} += $incl_time;
	     $sum->{excl} += $excl_time;
	     $sum->{ucpu} += $ucpu_time;
	     $sum->{scpu} += $scpu_time;
	     $sum->{reci} += $reci_time;
	     $sum->{depth} = $rec_depth if $rec_depth > $sum->{depth};
	 } else {
	     # New;
	     $callers{"$fid,$line"}{$called}{$caller} =
		 {
		  depth => $rec_depth,
		  count => $count,
		  incl => $incl_time,
		  excl => $excl_time,
		  ucpu => $ucpu_time,
		  scpu => $scpu_time,
		  reci => $reci_time,
		 };
	 }
     },
     SRC_LINE => sub {
	 my (undef, $fid, $line, $text) = @_;
	 confess("No mapping for $fid") unless defined $fids{$fid};
	 $fid = $fids{$fid};
	 # Is this a subroutine (re)defined in an eval?
	 my $mapped_fid = $map_range{$fid}[$line];
	 $fid = $mapped_fid if defined $mapped_fid;
	 $out->write('S');
	 $out->output_int($fid, $line);
	 $out->output_str($text);
     },
    );

foreach $input (@ARGV) {
    print "Reading $input...\n" if $opt_verbose;
    @pending_fids = ();
    %pending_subs = ();

    for_chunks {
	my $tag = shift;
	if($tag eq 'NEW_FID') {
	    my ($fid, $eval_fid, $eval_line, $flags, $size, $mtime, $name) = @_;
	    my ($new_fid, $new_eval_fid);
	    if($eval_fid) {
		# Generally, treat every eval as distinct, even at the same location
		$new_eval_fid = $fids{$eval_fid};
		confess("unknown eval_fid $eval_fid") unless defined $new_eval_fid;

		$new_fid = $next_fid++;
		$fids{$fid} = $new_fid;

		# But also track the first fid to be allocated at that line of the eval
		my $folded_fid = $fids_folded{$eval_fid};
		confess("unknown folded eval_fid $eval_fid") unless defined $folded_fid;

		my $corresponding_eval = $eval_to_fid{"$folded_fid,$eval_line"};
		if (!defined $corresponding_eval) {
		    # Not seen a fid generated in an eval at this location before
		    $eval_to_fid{"$folded_fid,$eval_line"} = $new_fid;
		    $fids_folded{$fid} = $new_fid;
		} else {
		    $fids_folded{$fid} = $corresponding_eval;
		}
	    } else {
		$new_eval_fid = $eval_fid;
		$new_fid = $file_to_fid{$name};

		if(defined $new_fid) {
		    $fids_folded{$fid} = $fids{$fid} = $new_fid;
		    return;
		}

		$new_fid = $next_fid++;
		$fids_folded{$fid} = $fids{$fid} = $new_fid;
		$file_to_fid{$name} = $new_fid;
	    }
	    $fid_to_file{$new_fid} = $name;
	    $pending_fids[$fid] = [$new_fid, $new_eval_fid];
	} elsif ($tag eq 'SUB_INFO') {
	    my ($fid, $first_line, $last_line, $name) = @_;
	    my $output_fid;
	    if ($name =~ $sub_is_anon_in_eval) {
		confess("No mapping for $fid") unless defined $fids{$fid};
		$output_fid = $fids{$fid};
		$seen_subs{"$output_fid,$name"} ||= "$first_line,$last_line";
	    } else {
		confess("No mapping for $fid") unless defined $fids_folded{$fid};
		my $folded = $fids_folded{$fid};
		my $seen = $seen_subs{"$folded,$name"};
		if (defined $seen && $seen ne "$first_line,$last_line") {
		    # Warn that we are not folding

		    # Carry on, and output a SUB_INFO block for this fid
		    $output_fid = $fid;
		} else {
		    # This subroutine has be (re)defined in two distinct
		    # evals, but appears to be identical. So for this lines
		    # range in the second eval, treat profiling data as if it
		    # came from the fid of the first eval, so that all calls
		    # to the sub are collated.

		    # Have to use the mapped fid as the key to this hash, as
		    # only the mapped fids are are unique
		    my $mapped_fid = $fids{$fid};
		    $map_range{$mapped_fid}[$_] = $folded
			for $first_line .. $last_line;

		    return if defined $seen;

		    $seen_subs{"$folded,$name"} = "$first_line,$last_line";
		    $output_fid = $folded;
		}
	    }
	    $pending_subs{"$fid,$first_line,$last_line,$name"} = $output_fid;
	}
    } filename => $input;

    print "Re-reading $input...\n" if $opt_verbose;
    for_chunks {
	my $sub = $dispatcher{$_[0]}
            or die "Unknown tag '$_[0]' in $input\n";
	&$sub(@_);
    } filename => $input;
}

print "Finalizing...\n" if $opt_verbose;
# Deterministic order is useful for testing.
foreach my $fid_line (sort keys %callers) {
    my ($fid, $line) = split ',', $fid_line;
    foreach my $called (sort keys %{$callers{$fid_line}}) {
	foreach my $caller (sort keys %{$callers{$fid_line}{$called}}) {
	    my $sum = $callers{$fid_line}{$called}{$caller};
	    $out->write('c');
	    $out->output_int($fid, $line);
	    $out->output_str($caller);
	    $out->output_int($sum->{count});
	    $out->output_nv(@{$sum}{qw(incl excl ucpu scpu reci)});
	    $out->output_int($sum->{depth});
	    $out->output_str($called);
	}
    }
}

foreach my $key (sort grep {!$identical{$_}} keys %attributes) {
    my @values = @{$attributes{$key}};
    if ($key eq 'basetime') {
	my $value = min(@values);
	$out->write(":$key=$value\n");
    } elsif ($key eq 'application') {
	my %counts;
	$counts{$_}++ foreach @values;
	my @grouped;
	foreach my $prog (sort keys %counts) {
	    my $count = $counts{$prog};
	    push @grouped,
		sprintf "$prog ($count run%s)", $count == 1 ? '' : 's';
	}
	my $last = pop @grouped;
	my $value = @grouped ? join (', ', @grouped) . " and $last" : $last;
	$out->write(":$key=$value\n");
    } else {
	warn "Unknown attribute $key\n";
	$out->write(":$key=$_\n") foreach @values;
    }
}

print "Done.\n" if $opt_verbose;
exit 0;

sub usage {
    print <<END;
usage: [perl] nytprofmerge [opts] nytprof-file [...]
 --out <file>,  -o <file>  Name of output file [default: $opt_out]
 --help,        -h         Print this message
 --verbose,     -v         Be more verbose

This script of part of the Devel::NYTProf distribution.
See http://search.cpan.org/dist/Devel-NYTProf/ for details and copyright.
END
    exit 1;
}

__END__

=head1 NAME

nytprofmerge - Reads multiple NYTProf profiles and outputs a merged one

=head1 SYNOPSIS

 $ nytprofmerge --out=nytprof-merged.out nytprof.out.*

 $ nytprofmerge nytprof.out.*

=head1 DESCRIPTION

Reads multiple profile data files generated by Devel::NYTProf and writes out
a new profile data file containing data merged from the original files.

C<nytprofmerge> is likely to produce garbage if the input profiles
aren't all profiles of exactly the same software.

C<nytprofmerge> is new and somewhat experimental. If it produces unexpected
results please produce a I<small> test case that demonstrates the problem and
let us know at L<http://groups.google.com/group/develnytprof-dev> - thanks!

=cut
